exit
self.children.all? {|child| child.winning_node?(evaluator)}
&& self.children.all? {|child| child.winning_node?(evaluator)}
evaluator
@next_mover_mark
n
evaluator
@next_mover_mark
n
@board.over?
self
@board
n
s
exit
n
@board.winner
!@board.winner
(!@board.winner || @board.winner == (evaluator==:x ? :o : :x))
@board.winner == evaluator
@board.over?
@board
n
s
exit
evaluator
self
evaluator
@board
evaluator
@next_mover_mark
n
self.children.all? do |child| child.losing_node?(evaluator) end
self.children.all? do |child| child.losing_node?(evaluator)
evaluator
@next_mover_mark
n
@board.over?
@boar.over?
evaluator
@board
n
s
exit
n
s
continue
@board
n
s
exit
@board
n
s
n
exit
continueexit
@board
continue
@board
n
@board
exit
@board
exit
@board
exit
@board
exit
@board
exit
@board
opponent_winner
exit
@board
n
evaluator
self.children.any? {|child| child.losing_node?(evaluator)}
self.children
evaluator
@next_mover_mark
n
evaluator
self
@board
marker
n
@board.over?
@board
exit
@board
exit
@board
continue
exit
n
exit
n
@board
continue
exit
@board.winner != evaluator
evaluator
self
@board.over?
@board
continue
continune
@board
continue
self
continue
@board
n
@board
n
@board
n
self.losing_node?(:o)
self
@board.over?
n
@board.winner != evaluator
@board.over?
evaluator
@board
exit
@board
continue
@board
continue
@board
continue
display @board
display j
display i
node_arr
n
new_prev_move_pos
n
new_mover_mark
n
dup_board
n
dup_board
n
s
exit
display node_arr
n
@prev_move_pos
n
@next_mover_mark
n
dup_board
n
dup_board
n
s
exit
exigt
exit
@prev_move_pos
@board
dup_board
n
next_mover_mark
n
s
exit
n
exit
n
display dup_board[[i,j]]
n
s
exit
display dup_board[[i,j]]
@board.dup
display dup_board[i,j]
dup_board[i,j]
n
s
display @board.empty?([i,j])
s
display row
s
exit
n
display i
s
exit
n
display i
i
s
@board
exit
exti
@board.rows
display @board.empty?([i,j])
@board.empty?([i,j])
s
@board.empty?([i,j])
@board
exit
n
display i
show i
i
s
display dup_board
